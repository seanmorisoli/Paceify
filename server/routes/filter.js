import express from 'express';
import fetch from 'node-fetch';
import { getUserSavedTracks, getRecommendations } from '../services/spotify.js';

const router = express.Router();

// Convert running pace to cadence (BPM)
function paceToBPM(minutes, seconds = 0, strideFeet = null) {
  const totalSeconds = minutes * 60 + seconds;
  const milesPerMinute = 1 / (totalSeconds / 60);
  const mph = milesPerMinute * 60;

  let stride = strideFeet;
  if (!stride) {
    stride = mph >= 8 ? 3.5 : mph >= 6.5 ? 3.2 : mph >= 5 ? 3 : 2.8;
  }

  return Math.round((milesPerMinute * 5280) / stride);
}

// POST /filter/filter
router.post('/filter', async (req, res) => {
  const { paceMinutes, paceSeconds, targetCadence, tolerance = 10, access_token } = req.body;
  const accessToken = req.headers.authorization?.replace('Bearer ', '') || access_token;

  if (!accessToken) return res.status(401).json({ error: 'Access token required' });

  let cadence;
  if (paceMinutes !== undefined) {
    cadence = paceToBPM(paceMinutes, paceSeconds);
  } else if (targetCadence) {
    cadence = targetCadence;
  } else {
    return res.status(400).json({ error: 'Provide pace or targetCadence' });
  }

  const minBPM = cadence - tolerance;
  const maxBPM = cadence + tolerance;

  try {
    // 1️⃣ Fetch user's saved tracks
    const userTracks = await getUserSavedTracks(accessToken, 50); // fetch 50 tracks
    // 2️⃣ Filter by BPM
    const filteredTracks = userTracks.filter(t => {
      const bpm = t.audio_features?.tempo;
      return bpm && bpm >= minBPM && bpm <= maxBPM;
    });

    // 3️⃣ If no tracks, fetch recommendations
    let finalTracks = filteredTracks;
    if (filteredTracks.length === 0) {
      const seedIds = userTracks.slice(0, 5).map(t => t.id);
      const recommended = await getRecommendations(
        { seed_tracks: seedIds, target_tempo: cadence, min_tempo: minBPM, max_tempo: maxBPM, limit: 20 },
        accessToken
      );
      finalTracks = recommended.filter(t => t.audio_features?.tempo >= minBPM && t.audio_features?.tempo <= maxBPM);
    }

    res.json({
      tracks: finalTracks.map(t => ({
        id: t.id,
        name: t.name,
        artists: t.artists.map(a => a.name).join(', '),
        album: t.album.name,
        duration_ms: t.duration_ms,
        bpm: Math.round(t.audio_features.tempo),
        uri: t.uri
      })),
      cadence,
      bpmRange: `${minBPM}-${maxBPM}`
    });

  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to fetch tracks' });
  }
});

// POST /playlists/create
router.post('/playlists/create', async (req, res) => {
  const { name, trackUris, access_token } = req.body;
  const accessToken = req.headers.authorization?.replace('Bearer ', '') || access_token;

  if (!accessToken) return res.status(401).json({ error: 'Access token required' });
  if (!trackUris || trackUris.length === 0) return res.status(400).json({ error: 'No tracks provided' });

  try {
    // 1️⃣ Create playlist
    const createRes = await fetch('https://api.spotify.com/v1/me/playlists', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, public: false, description: 'Generated by Paceify' })
    });
    const playlistData = await createRes.json();
    const playlistId = playlistData.id;

    // 2️⃣ Add tracks to playlist
    await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({ uris: trackUris })
    });

    res.json({ ...playlistData, trackCount: trackUris.length });

  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Failed to create playlist' });
  }
});

export default router;
